{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documenta\u00e7\u00e3o Simbiose","text":"<p>Aqui voc\u00ea encontrar\u00e1 toda a documenta\u00e7\u00e3o t\u00e9cnica da Simbiose Ventures. O objetivo deste documento, \u00e9 fornecer informa\u00e7\u00f5es que ir\u00e3o padronizar o desenvolvimento.</p>"},{"location":"#regras-atuais","title":"Regras atuais","text":"<p>Essas s\u00e3o regras definidas para guiar nossos projetos de uma forma padronizada, afim de manter qualidade e consist\u00eancia em toda a empresa.</p> <p>As regras n\u00e3o foram criadas para imp\u00f4r prefer\u00eancias pessoais de quaisquer membros da equipe.</p> <p>Como consequ\u00eancia das regras serem usadas para melhorar o trabalho, qualidade e consist\u00eancia, elas podem ser mudadas, caso uma maneira mais interessante e produtiva apare\u00e7a, portanto, n\u00e3o s\u00e3o absolutas. Caso tenha sugest\u00f5es para melhoras de nosso processo, basta entrar em contato e iremos todos discutir em conjunto.</p> <p>Todos os padr\u00f5es devem ser seguidos conforme orientado em cada um, para qualquer d\u00favida, sinta-se a vontade para fazer perguntas no Discord.</p>"},{"location":"#versionamento-e-branchs","title":"Versionamento e branchs","text":"<p>O modelo que devemos usar para desenvolver nossos projetos e organizar os reposit\u00f3rios \u00e9 o Git Flow.</p> <p>O modelo Git Flow \u00e9 descrito em detalhes aqui, \u00e9 necess\u00e1rio ler e entender ele por completo.</p> <p>Para auxiliar a seguir esse modelo, iremos usar a ferramenta git flow. Voc\u00ea pode ver um guia r\u00e1pido para instala\u00e7\u00e3o e uso dessa ferramenta aqui.</p> <p>Descri\u00e7\u00e3o mais detalhada da ferramenta aqui.</p>"},{"location":"#padronizacao-dos-nomes-dos-branches","title":"Padroniza\u00e7\u00e3o dos nomes dos branches","text":"<p>Para manter a organiza\u00e7\u00e3o dos reposit\u00f3rios de forma consistentes entre todos os projetos, devemos aplicar o padr\u00e3o seguinte (nos baseamos nesta padroniza\u00e7\u00e3o):</p> <ul> <li>Production releases branch: <code>master</code></li> <li>Development branch: <code>develop</code></li> <li>Feature branches: <code>feature/123-nome-da-feature</code></li> <li>Tests branches: <code>tests/123-nome-do-teste-ou-pacote</code></li> <li>Fixbugs branches: <code>fixbug/123-bug-sendo-resolvido</code></li> <li>Release branches: <code>release/x.x.x</code></li> </ul> <p>Obs.: Note que os n\u00fameros representam os IDs das tarefas sendo desenvolvidas</p>"},{"location":"#boas-praticas-de-programacao","title":"Boas pr\u00e1ticas de programa\u00e7\u00e3o","text":""},{"location":"#nomes","title":"Nomes","text":"<p>Para o significado dos nomes, como regra geral, \u00e9 bom adotar o formato:</p> <ul> <li>Vari\u00e1veis e classes s\u00e3o substantivos</li> <li>Fun\u00e7\u00f5es e m\u00e9todos s\u00e3o verbos</li> </ul> <p>O nome de uma vari\u00e1vel deve descrever o que a vari\u00e1vel representa de forma clara e n\u00e3o amb\u00edgua.</p> <p>Adote nomes que revelem a inten\u00e7\u00e3o da fun\u00e7\u00e3o.</p>"},{"location":"#ruim","title":"RUIM","text":"<p>send_http_data()</p> <pre><code># BOM\npost_twitter_status()\n</code></pre> <p>SEMPRE coloque nomes descritivos em fun\u00e7\u00f5es, vari\u00e1veis, classes, m\u00f3dulos, pacotes, etc.</p> <p>EVITE abrevia\u00e7\u00f5es a todo custo.</p> <pre><code># RUIM\nx = ['cat', 'dog']\nfor i in x:\n    i.spk()\n\n# BOM\nanimals = ['cat', 'dog']\nfor animal in animals:\nanimal.speak()\n</code></pre> <p>Respeite o padr\u00e3o de nomes da linguagem de forma consistente, n\u00e3o misture estilos de programa\u00e7\u00e3o. Ex: vari\u00e1veis em python se escrevem com snake_case e em Java com camelCase.</p> <pre><code># RUIM\nQtyOfCats = 4\nquantt_OF_Dogs = 2\n\n# BOM\nquantity_of_cats = 4\nquantity_of_dogs = 2\n</code></pre>"},{"location":"#espacamento","title":"Espa\u00e7amento","text":"<p>SEMPRE use espa\u00e7o ap\u00f3s <code>,</code> , <code>:</code> e entre operadores como <code>+</code> , <code>-</code> , <code>*</code> , etc.</p> <pre><code># RUIM\nsome_list = [1,2,3]\nsome_dict = {'key1':1, 'key2':2}\nexpression = var1+var2 -var3* var4\n\n# BOM\nsome_list = [1, 2, 3]\nsome_dict = {'key1': 1, 'key2': 2}\nexpression = var1 + var2 - var3 * var4\n</code></pre>"},{"location":"#estruturas-de-controle","title":"Estruturas de controle","text":"<p>A \"l\u00f3gica\" inversa dificulta o entendimento grandemente. D\u00ea prefer\u00eanca a testar pela \"verdade\" primeiro, e n\u00e3o no else.</p> <pre><code># RUIM\nif not ready:\n    do_something_else()\nelse:\n    do_something()\n\n# BOM\nif ready:\n    do_something()\nelse:\n    do_something_else()\n</code></pre> <p>Evite c\u00f3digo muito nested ao fazer valida\u00e7\u00f5es e retornos no in\u00edcio da l\u00f3gica. Isso tamb\u00e9m ajuda a separar o entendimento do que \u00e9 a parte principal do c\u00f3digo e o que s\u00e3o valida\u00e7\u00f5es, verifica\u00e7\u00f5es ou coisas que n\u00e3o tem a ver como fluxo principal da fun\u00e7\u00e3o. Isso pode parecer contradit\u00f3rio com o exemplo anterior, mas s\u00e3o situa\u00e7\u00f5es diferentes.</p> <pre><code># RUIM\ndef do_something():\n    if ready():\n        # This is the really important part of the code\n        # It's the core of \"do_something()\"\n        # Do a lot of stuff\n        # Do a lot of stuff\n        # Do a lot of stuff\n        return something\n    else:\n        # This is just some validation\n        return not_valid\n\n# BOM\ndef do_something():\n    if not ready:\n        # This is just some validation\n        return not_valid\n\n    # This is the really important part of the code\n    # It's the core of \"do_something()\"\n    # Do a lot of stuff\n    # Do a lot of stuff\n    # Do a lot of stuff\n    return something\n</code></pre>"},{"location":"#variaveis-globais","title":"Vari\u00e1veis globais","text":"<p>Regra geral: N\u00e3o use, a n\u00e3o ser que seja realmente o \u00fanico jeito de fazer ou que fazer de outra maneira aumentaria muito a complexidade ou mesmo teria que ser feito atrav\u00e9s de gambiarra.</p> <p>Regra especial para Javascript: Nessa linguagem as vezes \u00e9 mais dif\u00edcil fugir do uso de vari\u00e1veis globais. Como maneira de limitar o dano causado por isso, utilize uma \u00fanica vari\u00e1vel global chamada GLOBALS, que deve ser um objeto, e coloque nela quais outras vari\u00e1veis que voc\u00ea precisaria usar globalmente.</p> <pre><code>// RUIM\nGLOBAL_VARIABLE_A = 'something a'\nglobalVariableB = 'something b'\n\nconsole.log(GLOBAL_VARIABLE_A);\n\n// BOM\nGLOBALS = {\n    'variable_a': 'something a',\n    'variable_b': 'something b',\n}\nconsole.log(GLOBALS.variable_a);\n</code></pre>"},{"location":"#boas-praticas-em-pull-requests","title":"Boas pr\u00e1ticas em Pull Requests","text":""},{"location":"#padrao-dos-nomes-dos-prs","title":"Padr\u00e3o dos nomes dos PRs","text":"<p>Os nomes dos PRs devem ser compostos por uma frase sucinta de at\u00e9 120 caracteres que resuma bem qual funcionalidade est\u00e1 sendo adicionada ou qual bug est\u00e1 sendo resolvido naquele Pull Request. Abaixo voc\u00ea pode visualizar exemplos de um nome ruim e de um bom nome para determinado PR.</p> <pre><code>// RUIM\nfeature/create a new tool to the API query flow\n\n// BOM\nCreate a SQL parser method on the data access flow\n</code></pre>"},{"location":"#uso-de-labels","title":"Uso de labels","text":"<p>Nos reposit\u00f3rios da Simbiose \u00e9 uma regra que sejam definidas labels em seu PR, para facilitar a identifica\u00e7\u00e3o do status do seu trabalho. Isso ajuda o revisor a compreender o que ele deve ou n\u00e3o revisar e tamb\u00e9m d\u00e1 uma visibilidade para toda a equipe sobre o andamento de cada atividade definida. Abaixo voc\u00ea pode ver cada label poss\u00edvel de ser adicionada em um PR separada em dois grupos: tipo e estado. Portanto, todo PR deve conter uma label de cada grupo definido.</p> <p>Tipo do PR:</p> <ul> <li>Bug: informa que o PR foi criado para a resolu\u00e7\u00e3o de um bug do sistema;</li> <li>Feature: informa que o PR foi criado para adicionar uma nova funcionalidade ou melhorar alguma j\u00e1 existente;</li> <li>Test: informa que o PR foi criado para adicionar, corrigir ou melhorar testes existentes no sistema;</li> <li>Documentation: informa que o PR foi criado para adicionar alguma documenta\u00e7\u00e3o necess\u00e1ria no c\u00f3digo;</li> </ul> <p>Estado do PR:</p> <ul> <li>Changes Requested: informa que o PR foi revisado e algumas mudan\u00e7as foram requisitadas;</li> <li>In progress: informa que o PR ainda possui trabalho em desenvolvimento;</li> <li>Ready: informa que o trabalho executado no PR est\u00e1 finalizado e pode ser revisado;</li> <li>Temporary: informa que o PR \u00e9 tempor\u00e1rio e ser\u00e1 deletado quando n\u00e3o estiver sendo mais usado;</li> <li>Waiting: informa que o PR depende de outra tarefa para que seja mergeado;</li> </ul>"},{"location":"#padrao-de-mensagem-de-commit","title":"Padr\u00e3o de mensagem de commit","text":"<p>A motiva\u00e7\u00e3o de ter um padr\u00e3o de mensagem adv\u00e9m da necessidade de reler as mesmas para entender o que aconteceu recentemente em um reposit\u00f3rio a um n\u00edvel mais granular.</p> <p>O padr\u00e3o de commit que ser\u00e1 seguido est\u00e1 dispon\u00edvel online em Conventional Commits.</p> <p>Para toda mensagem de commit deve-se definir um dos prefixos abaixo:</p> <ul> <li>feat: add translation method to</li> <li>fix: solve bug on insertion flow</li> <li>test: add test for replication message</li> <li>docs: add parameter on query docstring</li> </ul> <p>Outro ponto importante \u00e9 a l\u00edngua na qual essas mensagens est\u00e3o escritas, que deve ser a mesma que o projeto usa, no nosso caso sempre o ingl\u00eas. O padr\u00e3o \u00e9 explicitar claramente e de maneira unit\u00e1ria o que foi alterado naquele commit como <code>feat: add core data replication structure</code>.</p> <p>Exemplos:</p> <pre><code># RUIM\nI have changed the data replication structure\n\n# BOM\nfeat: add core data replication structure\n</code></pre>"},{"location":"#test-driven-development","title":"Test Driven Development","text":"<p>Test driven development (TDD, ou, em portugu\u00eas, desenvolvimento guiado a testes) \u00e9 um processo de desenvolvimento de c\u00f3digo. Nele, deve-se primeiro criar um teste e ent\u00e3o escrever c\u00f3digo que fa\u00e7a este teste passar. Depois, repete-se para novas funcionalidades. O ciclo est\u00e1 apresentado abaixo.</p> <ol> <li>Adicione um teste</li> <li>Execute os testes e veja se o novo teste falha</li> <li>Escreva o c\u00f3digo</li> <li>Execute os testes</li> <li>Refatore o c\u00f3digo</li> <li>Repita</li> </ol> <p>Ao iniciar pelos testes, o programador deve entender bem os requerimentos para que o teste seja completo, evitando deixar um caso importante passar. Caso os testes falhem na primeira escrita de c\u00f3digo, devem ser modificados at\u00e9 que passem, somente. Otimiza\u00e7\u00f5es ser\u00e3o realizadas na etapa de refatora\u00e7\u00e3o do c\u00f3digo. O tamanho das etapas deve ser pequeno, de forma que se possa notar rapidamente se alguma modifica\u00e7\u00e3o quebrou outros testes.</p> <p>Importante: Leiam a p\u00e1gina da wiki que foi passada no primeiro par\u00e1grafo, escolha a l\u00edngua de sua prefer\u00eancia. H\u00e1 uma explica\u00e7\u00e3o para cada uma das etapas apresentadas, o que \u00e9 importante no desenvolvimento.</p>"},{"location":"#produtividade","title":"Produtividade","text":"<p>Dicas e ferramentas para ajudar na sua produtividade no dia a dia.</p>"},{"location":"#alias","title":"Alias","text":"<p>No dia a dia digitamos muitos comandos, alguns bem longos. Para otimizar esse processo uma boa maneira \u00e9 definir alias no sistema, ou seja, uma string que representa um atalho para um comando completo.</p> <p>Esses alias funcionam no Linux e no Mac e onde voc\u00ea os define depende do sistema e distribui\u00e7\u00e3o, geralmente pode ser no arquivo <code>~/.bashrc</code> ou <code>~/.zshrc</code>.</p> <p>Exemplo 1</p> <p>Se voc\u00ea desenvolve em django por exemplo, muitas vezes vai utilizar o comando python manage.py . Para otimizar esse trabalho voc\u00ea pode criar o alias: <pre><code>alias pman=\"python manage.py\"\n</code></pre> <p>E assim s\u00f3 precisa escrever <code>pman &lt;something&gt;</code>.</p> <p>Exemplo 2</p> <p>Este exemplo serve para facilitar o trabalho de entrar na pasta dos projetos e ativar ambientes virtuais. Voc\u00ea pode resumir dois comandos longos em poucos caracteres:</p> <pre><code>alias proj='cd ~/workspace/my_project; source ~/workspace/venvs/my_project/bin/activate'\n</code></pre> <p>Exemplo 3</p> <p>Ao usar o git, constantemente voc\u00ea usa diversos comandos, e apesar de serem curtos, podem tomar um tempo e paci\u00eancia razo\u00e1vel. Criar os seguintes alias pode ajudar muito:</p> <pre><code>alias gs='git status'\nalias ga='git add'\nalias gd='git diff'\nalias gda='git diff --staged'\nalias gc='git commit'\nalias gl='git log'\nalias gps='git push'\nalias gpl='git pull'\nalias gco='git checkout'\nalias gf='git fetch'\nalias gr='git rebase'\nalias gpr='git pull --rebase'\n</code></pre> <p>\u00c9 evidente que isso s\u00e3o exemplos e voc\u00ea pode definir como desejar, depende um pouco de seu gosto pessoal tamb\u00e9m.</p> <p>Exemplo 4</p> <p>Exemplos de alias para o gitflow:</p> <pre><code>alias gffs='git flow feature start'\nalias gfff='git flow feature finish'\nalias gffps='git flow feature publish'\nalias gffpl='git flow feature pull'\nalias gfrs='git flow release start'\nalias gfrps='git flow release publish'\nalias gfrt='git flow release track'\nalias gfrf='git flow release finish'\nalias gfhfs='git flow hotfix start'\nalias gfhff='git flow hotfix finish'\n</code></pre>"},{"location":"#ctrl-r","title":"ctrl + r","text":"<p>Ainda no sentido de diminuir o esfor\u00e7o de digitar e se lembrar de comandos, uma ferramente muito importante \u00e9 o ctrl + r. Essa ferramente pode ser usada no terminal do Linux e Mac, e o que faz \u00e9 buscar no hist\u00f3rico de comandos. Assim voc\u00ea pode achar facilmente aquele comando grep que voc\u00ea usou uma vez e foi muito \u00fatil, mas que n\u00e3o lembra mais.</p> <p>A busca do ctrl + r se limita aos comandos armazenados no seu hist\u00f3rico de comandos, por isso \u00e9 importante aumentar a quantidade de linhas que podem ser armazenadas, isso pode ser feito adicionando essas duas vari\u00e1veis de ambiente (no mesmo arquivo que voc\u00ea define os alias, por exemplo):</p> <pre><code>export HISTFILESIZE=10000\nexport HISTSIZE=10000\n</code></pre> <p>Aqui n\u00f3s definimos que o hist\u00f3rico armazena at\u00e9 10 mil linhas por vez, sempre apagando as mais antigas.</p>"},{"location":"#refactor","title":"Refactor","text":"<p>Como regra especial, fica definido que voc\u00ea n\u00e3o pode fazer um refactor de mais de 50% de um c\u00f3digo sem antes consultar o gestor do projeto e os respons\u00e1veis pelo c\u00f3digo que voc\u00ea quer refatorar. Isso \u00e9 importante para dar visibilidade a todos de uma mudan\u00e7a t\u00e3o grande e tamb\u00e9m para se avaliar em conjunto a necessidade desse refactor, pois v\u00e1rias horas de produtividade foram gastas ali.</p>"},{"location":"#complementos-git","title":"Complementos Git","text":"<p>Lista de bons materiais e links compartilhados por nossa equipe que dizem respeito \u00e0 Git (Versionamento de C\u00f3digo) e outros assuntos relacionados.</p> <p>Links \u00fateis:</p> <ul> <li>Git Cheat Sheet</li> <li>Tutorial Interativo do git</li> <li>Documenta\u00e7\u00e3o oficial do git</li> <li>Guia r\u00e1pido de comandos do git</li> <li>Screencast do Fabio ASkita sobre Git</li> <li>Pro Git livro gratuito</li> </ul>"},{"location":"#versionamento","title":"Versionamento","text":"<p>\"Um sistema de controle de vers\u00e3o (ou versionamento), \u00e9 um software com a finalidade de gerenciar diferentes vers\u00f5es no desenvolvimento de um documento qualquer. Esses sistemas s\u00e3o comumente utilizados no desenvolvimento de software para controlar as diferentes vers\u00f5es \u2014 hist\u00f3rico e desenvolvimento \u2014 dos c\u00f3digos-fontes e tamb\u00e9m da documenta\u00e7\u00e3o de software.\" - Wikipedia O Conceito de versionamento surgiu da necessidade de v\u00e1rios programadores trabalharem simultaneamente na mesma base de c\u00f3digo de forma eficiente e facil. O versionamento de c\u00f3digo permite que diferentes programadores, atrav\u00e9s de 'commits', submetam vers\u00f5es ou modifica\u00e7\u00f5es para um reposit\u00f3rio, em que os diferentes commits ser\u00e3o agregados.</p>"},{"location":"#o-git","title":"O Git","text":"<p>O Git \u00e9 um sistema de versionamento distribuido, ou seja, cada c\u00f3pia do c\u00f3digo fonte \u00e9 na verdade um reposit\u00f3rio em si, permitindo por exemplo que um programador possa submeter uma vers\u00e3o \u00e0 qualquer outro reposit\u00f3rio, sem que este seja necessariamente o reposit\u00f3rio central (e.g. um programador X pode submeter uma vers\u00e3o do c\u00f3digo \u00e0 outro programador Y diretamente, sem passar pelo github). Em um sistema Linux baseado em Debian, instalar o git \u00e9 simples:</p> <p><code>$ sudo apt-get install git</code></p> <p>Na S1mbi0se n\u00f3s utilizamos o Github como reposit\u00f3rio central. Para configurar o acesso ao reposit\u00f3rio central (Github) basta seguir as instru\u00e7\u00f5es no github: Generating SSH Keys</p>"},{"location":"#conceitos-no-git","title":"Conceitos no git","text":""},{"location":"#clone","title":"Clone","text":"<p>Para come\u00e7ar a usar uma base de c\u00f3digo existente, primeiro precisamos clonar um reposit\u00f3rio (geralmente o central). Ao clonar um reposit\u00f3rio, voc\u00ea ter\u00e1 em seu computador uma c\u00f3pia exata da base de c\u00f3digo, bem como dos metadados do git. Para clonar por exemplo o reposit\u00f3rio do AudienceUI, primeiro navegue at\u00e9 a sua pasta de projetos (e.g. ~/projects/):</p> <pre><code>$ cd ~/projects/\n</code></pre> <p>Depois, com suas chaves SSH configuradas no github, execute o clone:</p> <pre><code>$ git clone git@github.com:s1mbi0se/audienceui\n</code></pre> <p>Pronto, agora voc\u00ea tem uma c\u00f3pia da base de c\u00f3digo do AudienceUI, e pode navegar e visualizar os arquivos.</p>"},{"location":"#commit","title":"Commit","text":"<p>O commit, \u00e9 a maneira de criar um 'pacote' com suas modifica\u00e7\u00f5es, que pode ser submetido a outros reposit\u00f3rios. Por exemplo, voc\u00ea modificou (e/ou criou novos) arquivos na pasta templates relativos \u00e0 uma nova feature HTML. Primeiro voc\u00ea deve adicionar os arquivos modificados/adicionados ao processo de commit. voc\u00ea pode adicionar arquivos espec\u00edficos, caso n\u00e3o queira submeter todas as modifica\u00e7\u00f5es, ou adicicionar todos:</p> <pre><code>$ # Adicionando um arquivo espec\u00edfico:\n$ git add caminho/para/arquivo/teste.html\n$ # Adicionando todos os arquivos que foram modificados/adicionados:\n$ git add --all\n</code></pre> <p>Com os arquivos adicionados, voc\u00ea pode agora \"gerar um pacote\" com suas modifica\u00e7\u00f5es, o tal do commit:</p> <pre><code>$ git commit -m \"Implementada feature XYZ\"\n</code></pre> <p>O par\u00e2metro '-m' se refere \u00e0 mensagem agregada ao commit, ele \u00e9 obrigat\u00f3rio e essencial para sabermos exatamente quais modifi\u00e7\u00f5es foram feitas neste commit.</p>"},{"location":"#pull","title":"Pull","text":"<p>O 'pull' \u00e9 a maneira padr\u00e3o de atualizar o reposit\u00f3rio local com os commits de um reposit\u00f3rio remoto. Ao fazer um 'pull' voc\u00ea estar\u00e1 efetivamente 'puxando' os commits do reposit\u00f3rio remoto e aplicando-os ao reporit\u00f3rio local. O pull est\u00e1 intrinsicamente ligado ao conceito de 'Branch' ao qual n\u00e3o entrarei em muitos detalhes neste crash course. Para entender o conceito de branch por favor consulte o link: O Que \u00e9 um branch</p> <p>A sintaxe do pull \u00e9 bem simples:</p> <pre><code>$ git pull\n</code></pre> <p>O pull efetivamente copiar\u00e1 os commits do reposit\u00f3rio do github e os aplicar\u00e1 em seu reposit\u00f3rio local. Se houver algum arquivo conflitante (que foi modificado por voc\u00ea e por algum outro, de tal modo que o git n\u00e3o consiga junt\u00e1-los automaticamente) voc\u00ea receber\u00e1 um aviso de que os arquivos devem ser 'mergeados'. O Merge ser\u00e1 tratado com mais detalhes em um t\u00f3pico abaixo.</p>"},{"location":"#push","title":"Push","text":"<p>O 'push' \u00e9 maneira padr\u00e3o de submeter commits do reposit\u00f3rio local ao reposit\u00f3rio remoto. Ao fazer o 'push' voc\u00ea estar\u00e1 efetivamente 'empurrando' os commits locais ao reposit\u00f3rio remoto. A sintaxe do push \u00e9 identica \u00e0 do pull:</p> <pre><code>$ git push\n</code></pre> <p>Nota: Sempre fa\u00e7a um pull antes de fazer um push, para evitar Fast-Forwards.</p>"},{"location":"#fast-forward","title":"Fast-Forward","text":"<p>O fast-forward \u00e9 quando dois reposit\u00f3rios divergiram em seus commits e um pull ou push foi acionado. e.g. Um reposit\u00f3rio originalmente em estado X foi modificado pelo programador P1 e pelo programador P2, que geraram os commits C1 e C2 respectivamente. O Programador P1 ent\u00e3o faz push de seu commit para o github. O Programador P2, far\u00e1 ent\u00e3o um pull para garantir que esteja atualizado com a ultima vers\u00e3o do github, e a\u00ed ent\u00e3o ocorrer\u00e1 um fast forward. O commit C1 ser\u00e1 trazido do servidor para o computador do progamador P2 e ser\u00e1 'mergeado' com o commit C2. S\u00f3 depois deste merge (que pode ter sido autom\u00e1tico ou manual), o programador P2 far\u00e1 um push e enviar\u00e1 o commit C2 para o servidor, deixando o github atualizado com os commits C1 e C2. Note que por quest\u00f5es de consist\u00eancia, o github bloqueia fast-forwards em seus servidores, portanto se o programador P2 n\u00e3o fizesse o pull, e fosse direto ao push, o git mostraria uma mensagem de erro, avisando que o reposit\u00f3rio divergiu, e que \u00e9 necessario fazer um pull e merge locais antes de submeter o seu commit.</p>"},{"location":"#merge","title":"Merge","text":"<p>O Merge acontece quando duas vers\u00f5es divergentes da base de c\u00f3digo precisam ser agregadas. No exemplo do fast-forward acima, o merge ocorre quando P2 faz o pull. O git automaticamente tentar\u00e1 juntar os arquivos e gerar um novo novo commit que \u00e9 o resultado da combina\u00e7\u00e3o C1+C2. O git faz um trabalho muito bom em merges autom\u00e1ticos, mas em alguns casos ele pode n\u00e3o conseguir mergear alguns arquivos, e gerar\u00e1 uma mensagem de conflito. Neste caso precisamos fazer o merge manual, via o comando:</p> <pre><code>$ git mergetool\n</code></pre> <p>Assim que voc\u00ea tiver resolvido os conflitos pela ferramenta de merge, Voc\u00ea ter\u00e1 de 'terminar' o commit de merge que o git abriu automaticamente, com:</p> <pre><code>$ git commit\n</code></pre> <p>Note que neste caso, n\u00e3o devemos passar o argumento '-m' para o commit, pois uma mensagem detalhada com o que foi mergeado \u00e9 gerada pelo git. Assim que acionar o commit acima, o git abrir\u00e1 um editor de arquivos em seu terminal com a mensagem que foi gerada pelo merge (voc\u00ea pode modific\u00e1-la se quiser), geralmente o VIM ou o nano. Salve o arquivo e feche o editor (':wq [enter]' no VIM e ctrl-o ctrl-x no nano), e est\u00e1 pronto o merge.</p>"}]}